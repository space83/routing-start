{"ast":null,"code":"import { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function expand(project, concurrent = Number.POSITIVE_INFINITY, scheduler = undefined) {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return source => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexport class ExpandOperator {\n  constructor(project, concurrent, scheduler) {\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n  }\n  call(subscriber, source) {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  }\n}\nexport class ExpandSubscriber extends OuterSubscriber {\n  constructor(destination, project, concurrent, scheduler) {\n    super(destination);\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n    this.index = 0;\n    this.active = 0;\n    this.hasCompleted = false;\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n  static dispatch(arg) {\n    const {\n      subscriber,\n      result,\n      value,\n      index\n    } = arg;\n    subscriber.subscribeToProjection(result, value, index);\n  }\n  _next(value) {\n    const destination = this.destination;\n    if (destination.closed) {\n      this._complete();\n      return;\n    }\n    const index = this.index++;\n    if (this.active < this.concurrent) {\n      destination.next(value);\n      let result = tryCatch(this.project)(value, index);\n      if (result === errorObject) {\n        destination.error(errorObject.e);\n      } else if (!this.scheduler) {\n        this.subscribeToProjection(result, value, index);\n      } else {\n        const state = {\n          subscriber: this,\n          result,\n          value,\n          index\n        };\n        this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n  subscribeToProjection(result, value, index) {\n    this.active++;\n    this.add(subscribeToResult(this, result, value, index));\n  }\n  _complete() {\n    this.hasCompleted = true;\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this._next(innerValue);\n  }\n  notifyComplete(innerSub) {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n}\n//# sourceMappingURL=expand.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}